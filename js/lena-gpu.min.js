!function(t) {
    var e = {
        filterDataFunc: function(t, e, s, r) {
            for (var n = 0, i = 0, h = 0, a = this.constants.fw,
                     u = this.constants.fh, o = this.constants.fw2,
                     c = this.constants.fh2, l = 0;
                 l < u; l++)
                for (var f = 0; f < a; f++) {
                    var p = 4 *
                        ((this.thread.y - c + l) * s + (this.thread.x - o + f));
                    n += t[p + 0] * e[l * a + f], i += t[p + 1] * e[l * a + f],
                        h += t[p + 2] * e[l * a + f]
                }
            return exports(n, i, h, 1)
        },
        filterFunc: function(t, e) {
            for (var s = 0, r = 0, n = 0, i = this.constants.fw,
                     h = this.constants.fh, a = this.constants.fw2,
                     u = this.constants.fh2, o = 0;
                 o < h; o++)
                for (var c = 0; c < i; c++) {
                    const h = t[this.thread.y - u + o][this.thread.x - a + c];
                    s += h[0] * e[o * i + c], r += h[1] * e[o * i + c],
                        n += h[2] * e[o * i + c]
                }
            return exports(s, r, n, 1)
        }
    },
        s = {
            gray: function(t, e, s) {
                var r = t[this.thread.y][this.thread.x], n = r[0], i = r[1],
                    h = r[2], a = (r[3], .2126 * n + .7152 * i + .0722 * h);
                return exports(a, a, a, 1)
            },
            thresholding: function(t, e, s) {
                var r = t[this.thread.y][this.thread.x], n = r[0], i = r[1],
                    h = r[2], a = (r[3], .2126 * n + .7152 * i + .0722 * h);
                return a > e && a < s || (n = i = h = 0), exports(n, i, h, 1)
            },
            thresholding2: function(t, e, s) {
                var r = t[this.thread.y][this.thread.x], n = r[0], i = r[1],
                    h = r[2], a = (r[3], .2126 * n + .7152 * i + .0722 * h);
                return n = i = h = a > e && a < s ? 1 : 0, exports(n, i, h, 1)
            },
            invert: function(t, e, s) {
                var r = t[this.thread.y][this.thread.x];
                var  n = 1 - r[0];
                var  i = 1 - r[1]; var  h = 1 - r[2];
                return exports(n, i, h, 1)
            },
            red: function(t, e, s) {
                var r = t[this.thread.y][this.thread.x];
                return exports(r[0], 0, 0, 1)
            },
            green: function(t, e, s) {
                var r = t[this.thread.y][this.thread.x];
                return exports(0, r[1], 0, 1)
            },
            blue: function(t, e, s) {
                var r = t[this.thread.y][this.thread.x];
                return exports(0, 0, r[2], 1)
            },
            saturation: function(t, e) {
                var s = t[this.thread.y][this.thread.x], r = .3086 * (1 - e),
                    n = .3086 * (1 - e), i = .6084 * (1 - e),
                    h = .6084 * (1 - e) + e, a = .6084 * (1 - e),
                    u = .082 * (1 - e), o = .082 * (1 - e),
                    c = .082 * (1 - e) + e,
                    l = (.3086 * (1 - e) + e) * s[0] + i * s[1] + u * s[2],
                    f = r * s[0] + h * s[1] + o * s[2],
                    p = n * s[0] + a * s[1] + c * s[2];
                return exports(l, f, p, 1)
            },
            sepia: function(t, e, s) {
                var r = t[this.thread.y][this.thread.x], n = r[0], i = r[1],
                    h = r[2], a = (r[3], .3 * n + .59 * i + .11 * h);
                return exports(a + 40 / 255, a + 20 / 255, a - 20 / 255, 1)
            },
            mirror: function(t, e, s) {
                var r = t[this.thread.y][e - this.thread.x];
                return exports(r[0], r[1], r[2], 1)
            },
            flip: function(t, e, s) {
                var r = t[s - this.thread.y][this.thread.x];
                return exports(r[0], r[1], r[2], 1)
            },
            passthrough: function(t, e, s) {
                var r = t[this.thread.y][this.thread.x];
                return exports(r[0], r[1], r[2], 1)
            }
        };
    cfunc = {
        gradient: function(t) {
            function e(t, e, s, r, n, i) {
                return t * r + e * n + s * i
            }
            var s = this.thread.x, r = this.thread.y;
            const n = t[r - 1 + 0][s - 1 + 0], i = t[r - 1 + 0][s - 1 + 1],
                  h = t[r - 1 + 0][s - 1 + 2], a = t[r - 1 + 1][s - 1 + 0],
                  u = (t[r - 1 + 1][s - 1 + 1], t[r - 1 + 1][s - 1 + 2]),
                  o = t[r - 1 + 2][s - 1 + 0], c = t[r - 1 + 2][s - 1 + 1],
                  l = t[r - 1 + 2][s - 1 + 2];
            var f, p;
            p = e(n[0], i[0], h[0], .25, .5, .25) +
                e(o[0], c[0], l[0], -.25, -.5, -.25),
            f = e(n[0], a[0], o[0], .25, .5, .25) +
                e(h[0], u[0], l[0], -.25, -.5, -.25);
            var g, d;
            return g = Math.sqrt(f * f + p * p), d = Math.atan2(p, f),
                   exports(g, d, 0, 1)
        },
        nonMaximumSuppression: function(t, e) {
            for (var s = this.thread.x, r = this.thread.y, n = t[r][s][0],
                     i = 0;
                 i < 5; i++)
                for (var h = 0; h < 5; h++) {
                    const u = t[r - 2 + i][s - 2 + h],
                          o = e[r - 2 + i][s - 2 + i], c = u[0], l = o[1];
                    var a = Math.atan2(i - 2, h - 2);
                    c * Math.abs(Math.cos(l - a)) > n && (n = 0)
                }
            return exports(2 * n, 2 * n, 2 * n, 1)
        }
    };
    var r = {
        gaussian: [1 / 16, .125, 1 / 16, .125, .25, .125, 1 / 16, .125, 1 / 16],
        bigGaussian: [
            2 / 159,  4 / 159, 5 / 159, 4 / 159,  2 / 159,  4 / 159,  9 / 159,
            12 / 159, 9 / 159, 4 / 159, 5 / 159,  12 / 159, 15 / 159, 12 / 159,
            5 / 159,  4 / 159, 9 / 159, 12 / 159, 9 / 159,  4 / 159,  2 / 159,
            4 / 159,  5 / 159, 4 / 159, 2 / 159
        ],
        highpass: [-1, -1, -1, -1, 8, -1, -1, -1, -1],
        laplacian: [0, -1, 0, -1, 4, -1, 0, -1, 0],
        lowpass3:
            [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9],
        lowpass5: [
            .04, .04, .04, .04, .04, .04, .04, .04, .04, .04, .04, .04, .04,
            .04, .04, .04, .04, .04, .04, .04, .04, .04, .04, .04, .04
        ],
        prewittHorizontal:
            [1 / 3, 1 / 3, 1 / 3, 0, 0, 0, -1 / 3, -1 / 3, -1 / 3],
        prewittVertical: [-1 / 3, 0, 1 / 3, -1 / 3, 0, 1 / 3, -1 / 3, 0, 1 / 3],
        roberts: [0, 0, 0, 1, -1, 0, 0, 0, 0],
        sharpen: [0, -.2, 0, -.2, 1.8, -.2, 0, -.2, 0],
        sobelHorizontal: [.25, .5, .25, 0, 0, 0, -.25, -.5, -.25],
        sobelVertical: [.25, 0, -.25, .5, 0, -.5, .25, 0, -.25]
    };
    class n {
        constructor(t = {}) {
            this.width = t.width || null, this.height = t.height || null;
            var r = t.graphical || !0;
            this.gpu = t.gpu || new GPU, n.gpu = n.gpu || this.gpu,
            this.dynamicOutput = !this.width || !this.height;
            let i = {
                constants: {fw: 3, fh: 3, fw2: 1, fh2: 1},
                dynamicOutput: this.dynamicOutput,
                graphical: r
            },
                h = {
                    constants: {fw: 5, fh: 5, fw2: 2, fh2: 2},
                    dynamicOutput: this.dynamicOutput,
                    graphical: r
                },
                a = {dynamicOutput: this.dynamicOutput, graphical: r}, u = {
                    dynamicOutput: this.dynamicOutput,
                    constants: {fw: 3, fh: 3, fw2: 1, fh2: 1}
                },
                o = {
                    dynamicOutput: this.dynamicOutput,
                    constants: {fw: 5, fh: 5, fw2: 2, fh2: 2}
                };
            var c = [function exports(t, e, s, r) {
                this.color(t, e, s, r); return 0;
            }],
                l = [function exports(t, e, s, r) {
                    return [t, e, s, r]
                }];
            for (var f in this.gfxkernels = {}, this.cskernels = {},
                          this.gfxkernels.conv3x3canvas =
                              this.gpu.createKernel(e.filterDataFunc, i),
                          this.gfxkernels.conv5x5canvas =
                              this.gpu.createKernel(e.filterDataFunc, h),
                          this.gfxkernels.conv3x3 =
                              this.gpu.createKernel(e.filterFunc, i),
                          this.gfxkernels.conv5x5 =
                              this.gpu.createKernel(e.filterFunc, h),
                          s)
                this.gfxkernels[f] = this.gpu.createKernel(s[f], a),
                this.cskernels[f] = this.gpu.createKernel(s[f], u);
            for (var f in cfunc)
                this.cskernels[f] = this.gpu.createKernel(cfunc[f], u);
            if (this.cskernels.conv5x5 = this.gpu.createKernel(e.filterFunc, o),
                this.cskernels.conv3x3 = this.gpu.createKernel(e.filterFunc, u),
                this.width && this.height) {
                let t = this.width, e = this.height;
                for (var p in this.gfxkernels)
                    this.gfxkernels[p].setOutput([t, e]).setFunctions(c);
                for (var p in this.cskernels)
                    this.cskernels[p].setOutput([t, e]),
                        this.cskernels[p].setPipeline(!0).setFunctions(l)
            }
        }
        setOutput(t, e, s) {
            this.dynamicOutput &&
                (t.setOutput([e, s]), t.canvas.width = e, t.canvas.height = s)
        }
        convolution(t, e, s) {
            n = 0, console.log('this is a ' + n);
            var n, i = this.gfxkernels.conv3x3;
            let h = t.width || this.width, a = t.height || this.height;
            if ('string' == typeof e && (e = r[e]),
                null == e || null == h || null == a)
                return null;
            if (t.hasOwnProperty('data1d') && Array.isArray(t.data1d)) {
                let s = t.data1d;
                9 == e.length ?
                    i = this.gfxkernels.conv3x3canvas :
                    25 == e.length && (i = this.gfxkernels.conv5x5canvas),
                    this.setOutput(i, h, a), i.data = i(s, e, h, a)
            } else
                9 == e.length ? i = this.gfxkernels.conv3x3 :
                                25 == e.length && (i = this.gfxkernels.conv5x5),
                                this.setOutput(i, h, a), i.data = i(t, e);
            return this.present(i, s, h, a), i
        }
        filterImage(t, e, s) {
            let n = r[e];
            return this.convolution(t, n, s)
        }
        opsImage(t, e, s, ...r) {
            let n = e.width || this.width, i = e.height || this.height, h = t;
            return ('string' == typeof t || t instanceof String) &&
                       (h = this.gfxkernels[t]),
                   this.setOutput(h, n, i),
                   h.data = h.apply(null, [e].concat(r)),
                   this.present(h, s, n, i), h
        }
        present(t, e, s, r) {
            if (e && e != t.canvas) {
                var n = e.getContext('2d');
                e.width = s, e.height = r,
                n.putImageData(new ImageData(t.getPixels(), s, r), 0, 0)
            }
        }
        saturation(t, e, s) {
            return s = s || 2.9, this.opsImage('saturation', t, e, s)
        }
        thresholding(t, e, s, r) {
            return s = s || .25, r = r || .75,
                   this.opsImage('thresholding', t, e, s, r)
        }
        canny(t, e, ...s) {
            this.cskernels.gradient;
            let n = t.width || this.width, i = t.height || this.height;
            var h = this.cskernels.gray(t, n, i),
                a = this.cskernels.conv5x5(h, r.bigGaussian),
                u = this.cskernels.gradient(a),
                o = this.cskernels.conv3x3(a, r.laplacian),
                c = this.cskernels.nonMaximumSuppression(o, u),
                l = this.cskernels.thresholding2(c, .02, .613);
            return this.gfxkernels.passthrough(l, n, i),
                   this.present(this.gfxkernels.passthrough, e, n, i),
                   this.gfxkernels.passthrough
        }
    }
    function i(t) {
        let e = r[t];
        return function(t, s) {
            return this.convolution(t, e, s)
        }
    }
    for (var h in r) n.prototype[h] = i(h);
    function a(t) {
        return function(e, s) {
            return this.opsImage(t, e, s, e.width, e.height)
        }
    }
    for (var u
             of [['grayscale', 'gray'], ['invert'], ['red'], ['blue'],
                 ['green'], ['sepia'], ['mirror'], ['flip']]) {
        let t = u[0], e = 1 == u.length ? u[0] : u[1];
        n.prototype[t] = a(e)
    }
    t.LenaGPU = n
}(window);
